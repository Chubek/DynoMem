# DynoMem: A Jurassic Approach to Memory in x86-64 and Aarch64 Assembly

UNDER ACTIVE DEVELOPMENT

# Introduction

DynoMem is a part of [TransGatacca](https://github.com/chubek/TransGatacca). It is a small piece of code used in this application to allocate, unallocate, reallocate, copy memory and also contains implementation of strlen and strcpy.

For memory mapping DynoMem relies on simple syscalls, but for strlen, memcpy, and strcpy, DynoMem tries to have a novel approach.

Code for DynoMem is available in Github's Gist form, and hosted on the same website within this very repository.

DynoMem subroutines call using C convention so they are usable within C and other languages that adapt/use C calling convention. In fact, TransGatacca is a library written to be used with C.


# Syscall-Based Subroutines (`dynoalloc`, `dynorealloc`, `dynounalloc`)

## Memory in Linux

### Virtual Memory

In the early implementations of Vonn Neumann Architecture, memory blocks were a "place", within the realm of reality, where you could walk to, and touch with your hands. Programmers had, under their finger knuckles, calli. Because they had to flip switches repeatedly to set contents of a memory address. Most of these calli were because of the addressing. Now I could be wrong about the calli, as I am not hip to 50s skincare routines. But this 'absolute' method of memory addressing is just not efficient. It disallows, most importantly, even two programs being run on a computer by two programmers. Unless they have ae very robust protocol for knowing which address is being used by whom, it's just a deadend in most cases.

Virtuaal memory fixes this issue. A virtual memory is job #1 of an operating system, and memory virtualizers were the earliest form of operating systems. Within the framework of a virtual memory, a program need not care if an address being used by another program, as the program has been **linked** to certain addresses that can be managed easily. Memory is *dynamic* and *random access*.

### Linking to Virtual Memory

As I said, in programming, programs known as *linkers* (and their more primal version *loaders*) are used to *map* an object file, generated by a compiler or an assembler, to the virtual memory. In Linux and other Unix-like systems, this program is known as **ld**. But how does Linux gain access to memory? As a young lad I used to [try to] make NES games with 6502 assembly. In a 6502 device, programmer has access to memory, as virtualized by hardware, raw. In this language, you can prefix any number with `$` and it would become a memory address. In x86-64 and Aarch64 assembly, you can set a memory address, ONLY if you have that address. You may not declare an address for yourself. That's the job of operating system. Because memory is just another device connected to CPU that interfaces with it through the buses that CPU is connected with.

### Memory as a Device

Linux interfaces with memory as what is called a *block device*. There are several types of devices in Linux, all of which are identified through the computer's firmware that pulls all the buses together. There's network devices, character devices, and block devices. A block device in Linux is charactrized as being randon-access so RAM is the best fit for it. 

From there on you can use simple syscalls to allocate, reallocate, and unallocate memory. You cannot allocate memory for another process unless that memory is shared. Memory allocated by a process is only accessible by that process. However, shared memories are accessible by all the processes.

In Linux every device is a file and can be accessed to via a file descriptor. But if you wish to access all dynamic memory you can use file descriptor `-1`. 

## DynoMem's Memory Operation

DynoMem is a very simple library, and it only has a handful of subroutines. Three of which deal with memory allocation, unallocation, and reallocation.

To allocate memory, we have to do what is called *mapping*. In memory mapping we take a memory address, and have Linux map that memory address continuously for n blocks. If you do not pass a memory address, Linux will use one in the range that the application has been linked to. Linux first makes sure that memory block is 1- within the limits of the device(s) 2- unallocated/junked. If there's no unallocated or junked memory left to fit your size, it will segfault. 

But where in the application are these blocks allocated and how is their count kept? Each process in Linux has a stack, and a queue. Stack has the PCB or 'process call block' and queue keeps the count of allocated data. In virtual memory, the allocated data grow on top of each other, but in actual memory they could be anywhere. Stack keeps the count of called subroutines (the PCB) and is also the region that CPU would use as the 'global stack'. Contrast with 6502 where stack is a prefixed address range.

Reallocation is done by remapping the previously-allocated memory, and a new address is then returned. 

Notice that in both cases, as previously stated, you can pass your own address to be chosen as the starting block of the allocated/reallocated memory. But it's better if you don't. Unless you are sure that block is junk or unallocated.

And unallocation is done by unmapping the allocated memory. Then, the queue will go down and the place in actual memory will become available either for the process itself, or other processes, to use.

In all these cases, the size is in bytes. So if you wish to store 10 half-words (aka short, aka 16 bits) integers, you will have to pass a number of 20.

## Syscalls Used

For the operations, syscalls `mmap`, `mremap` and `munmap` are used accordingly. Table below shows the syscalls, their code in both archs, their arguments, and the register in which each argument must go in is indicated.


| Syscall |N. X64/rax | N. A64/x8 | rdi/x0 | rsi/x1 | rdx/x2 | r10/x3 |  r8/x4 | r9/x5 |Yields (rax/w0)|
|---------|-----------|-----------|--------|--------|--------|--------|--------|-------|---------------|
|  mmap   |     9     |    222    |  addr  |  size  |  prot  |  flags | fdesc  | offst |  addr. to mem | 
| mremap  |     25    |    216    | o.addr | o.size | n.size |  flags | n.addr |  ---  | n.addr to mem | 
| munmap  |     11    |    215    |  addr  |  size  |   ---  |   ---  |  ---   |  ---  |     None      |


## Notice

Always unallocate the previously-allocated memory before you quit the program. When a process terminates using SIGKILL (or CTRL + C), Linux does not unbind the memory in physical space. They will become junk memory in Linux's eyes. A new process may use this junk block to allocate new space dynamically, but unless that newly-allocated memory is unallocated, this space remains occupied as garbage and may create a lot of issues for other processes in the future. 



# Iteration-based Subroutines (`dynostlen`, `dynomemcpy`, `dynostrcpy`)




# Combining with `libc` Memory Functions (DON'T!, Well...)

It is not possible to combine DynoMem functions with that of of `libc`. The issue is, `dynosize` uses an entirely different method than `malloc/calloc`, `realloc`, `memcpy` etc to get the number of allocted bytes for `n` items. However, if you somehow pass `bytelen` for each function as one, and pass the size as the size that `libc` would allocate, you can manage to do that... but why? I'm not sure. I'm just covering all bases. As I mention in the [Disclaimer](#disclaimer) I am not to be held responsibe for unpredictable behavior of DynoMem. `libc` and `glibc` are written by giants of programming, and I'm just a dude with a computer and two working hands. Do as you wish, but don't hold me out on it!










# Disclaimer

This code does not come with any guarantees. Proceed to use at your own risk. It is not done as part of any paid projet. Nothing stands on the line for me regarding this code. So if you wish to use them in criticla situations, caution is necessary.